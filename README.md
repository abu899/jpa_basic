# JAVA Persistent API(JPA) Basic Study

## 목표

1. 객체와 테이블 설계 매핑
    - 객체와 테이블을 제대로 설계하고 매핑하는 방법
    - 기본 키와 외래 키 매핑
    - 1:N, N:1, 1:1, N:M 매핑

2. JPA 내부 동작 방식 이해
    - JPA의 내부 동작 방식을 이해하고 사용
    - JPA가 어떤 SQL을 만들어 내는지 이해
    - JPA가 언제 SQL을 실행하는지 이해

### ORM

- Object Relational Mapping(객체 관계 매핑)
- 객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스 대로 설계
- ORM 프레임워크가 중간에서 매핑

### Database Dialect

JPA는 특정 데이터베이스에 종속되지 않는다

- 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 다를 수 있다
    - 가변 문자: MySQL은 VARCHAR, Oracle은 VARCHAR2
    - 문자열을 자르는 함수: SQL 표준은 SUBSTRING(), Oracle은 SUBSTR()
    - 페이징: MySQL은 LIMIT , Oracle은 ROWNUM
- `Dialect`: SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능

## JPA의 구동 방식

<p align="center"><img src="/imgs/1.png" width="80%"></p>

### 주의사항

- `EntityManagerFactory`는 하나만 생성해서 어플리케이션 전체에서 공유한다
- `EntityManger`는 쓰레드간 공유가 안된다
    - 사용하고 버려야한다
- JPA의 모든 데이터는 `Transaction` 안에서 실행된다!! (매우 중요)

---

## Persistent Context (영속성 컨텍스트)

`Entity`를 영구 저장하는 환경이라는 뜻! 엄청나게 중요하다!

- EntityManager.persist(entity)
    - DB에 저장하는게 아니라 entity를 영속성 컨텍스트에 저장한다는 뜻이다
- 사실상 영속성 컨텍스트는 논리적인 개념
- `EntityManager`를 통해서 영속성 컨텍스트에 접근할 수 있다

### Entity의 생명주기

<p align="center"><img src="/imgs/2.png" width="80%"></p>

- 비영속(new/transient)
    - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속(managed)
  - 영속성 컨텍스트에서 관리되는 상태
  - em.persist한 후 commit되거나 find로 찾은 상태이다
- 준영속(detached)
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed)
  - 삭제된 상태

### 장점

- 1차 캐시
  - 영속성 컨텍스트 내부에는 캐시가 존재하여, 중복된 값은 캐시에서 가져올 수 있음
  - JPA에서 관리하는 상태
- 동일성 보장
  - 1차 캐시로 반복 가능한 읽기의 트랜잭션 격리 수준을, 데이터베이스가 아닌 어플리케이션 차원에서 공유
- 트랜잭션을 지원하는 쓰기를 지연한다
  - 트랜잭션을 커밋하는 순간 데이터베이스에 쿼리가 날아간다
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

### flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것

- 변경감지 실행
- 수정된 엔티티에 대한 `쓰기 지연 SQL 저장소`에 등록
- `쓰기 지연 SQL 저장소`의 쿼리를 데이터베이스에 전송한다
- 방법
  - em.flush()
  - 트랜잭션 커밋
  - JPQL 쿼리 실행
- 영속성 컨텍스트를 비우는 것이 아니다!
  - 영속성 컨텍스트의 `변경내용을 데이터베이스에 동기화` 하는것이라고 이해해야한다
- `트랜잭션이라는 작업 단위가 중요`하다
  - 영속성 컨텍스와 트랜잭션의 주기를 맞춰서 개발해야 데이터 동기화 같은 문제가 발생하지 않는다

### 준영속 상태

- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태
- 업데이트 할 때나, 더티 체킹(변경감지)이 불가능해진다
- 방법
  - EntityManager.detach(Entity)
  - EntityManager.clear()
  - EntityManager.close()

---

## Entity Mapping

### Overview

- 객체와 테이블 매핑
  - `@Entity`, `@Table`
- 필드와 컬럼 매핑
  - `@Column`
- 기본 키 매핑
  - `@Id`
- 연관관계 매핑
  - `@ManyToOne`, `@JoinColumn`

### @Entity

- `@Entity`가 붙은 클래스는 JPA가 관리하며 엔티티라고 한다
- JPA를 사용해서 테이블과 매핑하려는 클래스는 반드시! `@Entity` 필수
- 주의
  - 기본 생성자 필수!!(파라미터가 없는 public 또는 protected 생성자)
  - final 클래스, enum, interface, inner 클래스 사용하면 안된다
  - 저장할 필드에 final을 사용하면 안된다

--- 

## 연관관계 매핑 기초

### 목표

- 객체와 테이블 연관관계의 차이를 이해하자
  - 객체는 참조를 사용해서 연관된 관계를 찾는다
  - 테이블은 외래키로 조인을 사용해 연관된 테이블을 찾는다
- 객체의 참조(reference)와 테이블의 외래 키(FK)를 매핑
- 용어의 이해
  - 방향(Direction) : 단방향, 양방향
  - 다중성(Multiplicity) : 1:1, 1:N, N:1, N:N
  - `연관관계의 주인`: 객체 양방향 연관관계는 관리의 주인이 필요하다

### 단방향 연관관계

<p align="center"><img src="/imgs/3.png" width="80%"></p>
<p align="center"><img src="/imgs/4.png" width="80%"></p>

- 한쪽이 다른 한쪽을 참조하는 연관관계

### 양방향 연관관계

<p align="center"><img src="/imgs/5.png" width="80%"></p>

- 서로가 서로를 참조하는 관계
- 테이블 연관관계는 단방향과 차이가 없다

### 연관관계의 주인과 `mappedBy`

객체와 테이블간 연관관계를 맺는 차이를 이해해야한다.

- 객체간 연관관계
  - 양방향 연관관계를 살펴보면 사실 Member-> Team의 단방향 연관관계와 Team -> Member로의 단방향 연관관계
    - 서로의 객체 내에 참조하려는 대상을 가지고 있어야함!
  - 즉 두 개의 단방향 연관관계로 이루어져있다
- 테이블 연관관계 
  - 하지만 테이블 연관관계를 보면 Member의 TEAM_ID라는 외래키를 기준으로 양쪽의 데이터를 얻을 수 있다
    - Member 기준 TEAM_ID FK를 Team의 TEAM_ID PK를 join하면 내가 속한 team을 알 수 있다
    - Team 기준 TEAM_ID PK를 Member의 FK와 join하여 team에 소속된 member를 알 수 있다
  - 즉 테이블 연관관계에서 외래키 하나로 연관관계가 이루어져 있다

그렇다면 객체 두개 중 어떤 걸로 외래키를 관리해야 할까..? 즉 뭘로 매핑을 해야할까?
 
  - Member의 team 값을 바꿧을 때, 외래키 값이 업데이트 해야할까?
  - 아니면 Team의 members가 바꼈을 때, 외래키를 업데이트 해야할까? 

즉, 둘 중 하나로 외래키를 관리해야하는데 이 외래키를 관리하는 주체가 `연관관계의 주인(Owner)`이다.

- Owner만이 외래키를 등록하고 수정할 수 있다
  - 주인이 아닌 쪽은 오로지 읽기만 가능하다.
  - 주인이 아니면 `mappedBy` 속성으로 주인을 지정해줘야한다
- 외래 키가 존재하는 곳을 주인으로 정해야한다!
  - N:1(다대일), 1:N(일대다)같은 경우 N(다)쪽이 무조건 외래키가 있는 곳이므로 주인으로 지정하자

### 양방향 매핑 시 실수 및 주의점

1. 연관관계의 주인이 아닌 반대 객체(가짜 맵핑)에 값을 넣는 경우
  - 앞에 말했듯 주인만이 값을 등록하고 수정할 수 있기 때문에, 반대 객체에만 값을 넣는 경우 외래키가 null이 된다!!
  - 주인에만 값을 셋팅해주면 트랜잭션이 일어나는등 주인 객체의 값이 영속성 컨텍스트에 들어가면서, 반대 객체에도 값이 들어간다.
    - 하지만, 사실상 양쪽 모두에 값을 셋팅해주는게 좋다
    - 만약 영속화 되기전에 반대 객체에 대해 값을 요청한 경우, 아직 JPA가 반대 객체에 값을 넣어주기 전이기 때문에 값을 가져올 수 없다
    - 또한 직관적으로 값을 넣어주지도 않았는데, 값이 들어가는 것보단 비록 읽기만 가능한 반대 객체이지만 값을 넣어주는게 자연스럽다.
  - 따라서, 순수 객체 상태를 고려해서 양쪽에 값을 다 설정하자!
    - 연관관계 편의 메소드를 만들어서 적용하자
    - 연관관계 편의 메소드가 양쪽 객체에 모두 있는 경우 문제가 생길 수 있으므로, 하나의 객체를 정해서 넣어줘야한다.

2. 양방향 매핑시 무한루프를 조심해야한다
   - toString(), lombok, JSON 생성 라이브러리등..
     - StackOverflow Error 호출됨.

3. 단방향 매핑으로 설계를 완료하도록 노력하자.
   - 단방향 매핑으로 구조를 설계하고 꼭 필요할 때에 양방향을 사용하자.
   - 연관관계는 항상 외래키를 기준으로!

---

## 다양한 연관관계 매핑

### 연관관계 매핑시 고려사항

1. 다중성
   - 다대일 : `@ManyToOne`
   - 일대다 : `@OneToMany`
   - 일대일 : `@OneToOne`
   - 다대다 : `@ManyToMany`
     - 실무에서 절대 사용하면 안된다
2. 단방향, 양방향
   - 테이블
     - 외래 키(FK) 하나로 양쪽 조인 가능
     - 방향이라는 개념이 없다
   - 객체
     - 참조용 필드가 있는 쪽으로만 참조가 가능
     - 한 쪽만 참조하면 단방향
     - 양쪽이 서로 참조하면 양방향
3. 연관관계의 주인
   - 양방향의 경우 객체에는 참조가 2개가 존재하고, 이때 외래 키를 관리하는 참조
   - 주인의 반대편
     - 외래 키에 영향을 주지않음
     - 단순 조회만 가능하다

### 다대일 (N:1)

<p align="center"><img src="/imgs/6.png" width="80%"></p>
<p align="center"><img src="/imgs/7.png" width="80%"></p>

JPA에서 가장 많이 사용하고 중요한 연관관계

- 일대다의 반대 개념
- 다(N)쪽에 항상 외래키(FK)가 존재해야한다
- 다(N)쪽이 연관관계의 주인
  - 외래키가 있는 쪽이 연관관계의 주인

### 일대다 (1:N)

<p align="center"><img src="/imgs/8.png" width="80%"></p>
<p align="center"><img src="/imgs/9.png" width="80%"></p>

- 1이 연관관계의 주인이 된다
- 하지만 테이블 연관관계에서 보면 다쪽에 외래키가 존재하는 구조
- 객체와 테이블의 차이 때문에 반대편 테이블에 외래키가 존재하는 특이한 구조
- 실무에서는 잘 사용하지는 않는다
  - 업데이트 쿼리가 추가적으로 나가야한다
  - 연관관계의 주인을 업데이트하더라도, 외래키가 반대 객체에 존재하므로 업데이트 쿼리를 추가해야한다
  - 가장 큰 단점은 내가 건드리는 테이블이외에 다른 테이블에 대한 쿼리가 또 필요하므로 운영이 어려워짐.
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하는게 좋다!

### 일대일 (1:1)

<p align="center"><img src="/imgs/10.png" width="80%"></p>
<p align="center"><img src="/imgs/11.png" width="80%"></p>

- 주 테이블이나 대상 테이블 중에 외래 키 선택이 가능하다
  - 둘 중에 한군데에 넣으면 된다
- 외래 키에 데이터베이스 유니크 제약 조건을 추가해야 한다
- 다대일과 비슷비슷

### 다대다 (N:M)

<p align="center"><img src="/imgs/12.png" width="80%"></p>
<p align="center"><img src="/imgs/13.png" width="80%"></p>

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야한다!
- 편리해보이지만, 실무에서 사용하지 말자!
  - 연결 테이블이 단순 연결이 아닌 데이터가 들어오게되는 단점이 생긴다
- 연결테이블을 `@Entity`로 승격시키고, `@ManyToMany` -> `@OneToMany` + `@ManyToOne`으로 풀어나가야 한다

## 상속관계 매핑

객체는 상속 구조를 가질 수 있지만, 관계형 DB에서는 상속관계는 존재하지 않는다. 하지만 슈퍼타입과 서브타입 관계라는 
모델링 기법이 객체의 상속과 유사하게 동작한다.  
따라서, 상속관계 매핑이란 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 것이다.

### 조인 전략

<p align="center"><img src="/imgs/14.png" width="80%"></p>

- 정규화된 테이블 방식이며, 기본적으로 이 전략을 사용한다
- 공통된 데이터를 가진 테이블과 특수한 데이터를 가진 테이블 두개로 나눈다
  - 즉 아이템을 추가할 때 두 번의 insert가 실행된다.
- 공통의 id를 가지고 join을 통해 데이터를 가져올 수 있다
- 장점
  - 외래 키 참조 무결성 제약조건 활용가능
  - 저장공간 효율화
- 단점
  - 조회시 조인이 많이 사용, 성능 저하
  - 조회 쿼리가 복잡하다

### 단일 테이블 전략

<p align="center"><img src="/imgs/15.png" width="80%"></p>

- 논리 모델을 하나의 테이블로 합치는 구조
- 공통 속성 뿐만아니라 다른데이터도 하나의 테이블로 표현한다
- 단순하고 성능때문에 고려하는 경우도 존재한다
- 장점
  - 조인이 필요없고, 조회 성능이 빠르다
  - 조회 쿼리가 단순하다
- 단점
  - 자식 엔티티로 되어있는 모든 컬럼들에 대해 null을 허용해야한다
  - 단일 테이블에 모든걸 저장하기에 테이블이 커질 수 있다.

### 구현 클래스마다 테이블 전략

<p align="center"><img src="/imgs/16.png" width="80%"></p>

- 공통 속성을 없애고, 각각의 테이블이 모든 데이터를 가지는 구조
- 결론적으로 말하면, 실무에서는 쓰면 안되는 구조이다.
- 장점
  - 서브 타입을 명확하게 구분해서 처리할 때 효과적이다
  - not null 제약조건을 사용할 수 있다
- 단점
  - 여러 자식 테이블을 함께 조회할 때, 성능이 느리다(UNION)
  - 무엇보다 변경의 관점에서 불편한 구조.
  
### @MappedSuperclass  

<p align="center"><img src="/imgs/17.png" width="80%"></p>

- 공통 매핑 정보가 필요할 때 사용하며 엔티티도 아니고, 매핑과는 관련이 없다
- 부모 클래스를 상속 받는 자식 클래스에 `매핑 정보`만 제공한다
  - 조회, 검색 불가
  - 직접 테이블을 생성해서 사용하지 않기 때문에 추상클래스를 사용하는걸 권장한다
- 전체 엔티티에서 공통적으로 적용하는 정보를 모을 때 사용한다

> 참고로 `@Entity`class 는 같은 Entity나 MappedSuperclass로 지정한 클래스만 상속이 가능하다.
> Entity는 상속 관계 매핑, MappedSuperclass 속성만 상속받을 때 사용한다.

--- 

## 프록시

- em.find() vs em.getReference()
- em.find()
  - 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference()
  - 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

### 특징

- 실제 클래스를 상속받아서 만들어지기 때문에, 실제 클래스와 겉 모양이 같다.
- 프록시 객체는 실제 객체의 참조를 보관한다
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다
- 프록시 객체는 처음 사용할 때 한번만 초기화!
- 실제 엔티티로 바뀌는 것이 아니고, 초기화가 되면 프록시 객체를 통해 접근이 가능한 것이다
- 원본 엔티티를 상속받기 때문에 타입 체크시 주의해야한다(instance of)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있다면 getReference를 해도, 프록시가 아닌 실제 객체 반환
- 준영속 상태일때는, 프록시를 초기화에 문제가 생긴다!

### 즉시로딩과 지연로딩

- 지연 로딩 LAZY를 사용해서 프록시로 조회
  - `fetch = FetchType.LAZY`는 연관된 것을 프록시로!
  - 실제 사용하는 시점에 초기화를 진행한다!(DB 조회)
- 반면 즉시 로딩 EAGER를 사용하면 조인을 사용해서 SQL 한번에 함께 조회한다!

### 프록시와 즉시로딩 주의

- 실무에서는 가급적 지연 로딩만을 사용해야한다
  - 즉시 로딩을 적용하면 예상치 못한 SQL이 발생할 수 있다
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다
  - JPQL은 sql로 번역되서 데이터를 가져오고, EAGER로 설정된 데이터를 추가적인 쿼리를 통해 가져와야한다
- `@ManyToOne`, `@OneToOne`은 기본적으로 즉시 로딩이므로 LAZY로 설정해야한다

---

## 영속성 전이 : CASCADE

- 특정 엔티티를 영속 상태로 만들 때, 연관된 엔티티도 함께 영속상태로 만들고 싶을 때
- 연관 관계를 매핑하는 것과 전혀 관련이 없다!
- 종류
  - ALL
  - PERSIST
  - REMOVE
  
### 고아객체
- orphanRemoval = true
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
  - 참조하는 곳이 하나일 때 사용해야함!!
  - 특정 엔티티가 개인 소유할 때만 사용해야한다


### 영속성 전이 + 고아객체

- CascadeType.ALL + orphanRemoval=true
- 스스로 생명주기를 관리하는 엔티티는 em.persist로 영속화, em.remove로 제거한다
- 하지만 두 옵션을 모두 활성화하면, 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.

---

## 값 타입

값 타입 분류

- 기본 값 타입
    - 자바 기본 타입 (int, double)
    - Wrapper 클래스 (Integer, Long)
    - String
- 임베디드 타입
    - 복합 값 타입
- 컬렉션 값 타입

### 기본 값 타입

JPA의 데이터 타입 분류

- 엔티티 타입
  - `@Entity`로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적 가능하다
- 값 타입
  - int, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로, 변경시 추적 불가하다
  - 생명 주기를 엔티티에 의존한다
    - 회원을 삭제하면 이름, 나이 필드도 함께 삭제된다
  - 값 타입은 공유하면 안된다
    - 회원 이름 변경 시, 다른 회원의 이름도 변경되면 안된다

### 임베디드 타입

- 새로운 값 타입을 직접 정의할 수 있다
- 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
- int, String과 같은 값 타입이다
- 장점
  - 재사용이 용이하다
  - 높은 응집도를 가진다
  - 해당 값 타입만 사용하는 의미있는 메소드를 만들 수 있다
- 사용법
  - `@Embeddable`: 값 타입을 정의하는 곳에서
  - `@Embedded` : 값 타입을 사용하는 곳에서
  - 기본 생성자 필수!

#### 임베디드 타입과 테이블 매핑

- 임베디드 타입은 엔티티의 값일 뿐이다!
- 임베디드 타입을 사용하기 전과 후에 **매핑하는 테이블은 동일하다**
- 객체와 테이블을 세밀하게 매핑하는 것이 가능해진다!

### 값 타입과 불변 객체

- 임베디드 타입과 같은 값타입을 여러 엔티티에서 공유하면 위험하다
- 실제 인스턴스 값을 공유하는 것은 위험하고 값을 복사해서 사용해야한다!
- 한계
  - 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니고 객체 타입이다
    - 자바의 기본 타입은 대입이 기본적으로 복사이다
  - 따라서 참조 값을 직접 대입하는 것을 막을 방법이 없다
  - 객체의 공유 참조는 피할 수 없다.

### 불변 객체

- 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단할 수 있다
- 값 타입은 불변 객체(immutable object)로 설계해야한다
- 생성 시점 이후 절대 값을 변경 할 수 없는 객체!
- 생성자로만 값을 설정하고 setter를 만들지 않으면 됨

### 값 타입의 비교

- 인스턴스가 달라도 값이 같으면 같은 것으로 봐야한다
- 동일성(identity) 비교
  - 인스턴스의 참조 값을 비교, `==`을 사용한다
- 동등성(equivalence) 비교
  - 인스턴스의 값을 비교, `equals`를 사용한다
- 값 타입의 equals 메소드를 적절하게 재정의해서 사용해야한다

### 값 타입 컬렉션

- 값 타입을 하나 이상 저장할 때 사용한다
  - `@ElementCollection`, `@CollectionTable` 사용
- 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다
  - 컬렉션을 저장하기 위한 별도의 테이블이 필요하다!
- 값 타입 컬렉션은 생명주기가 따로 없이, 엔티티에 의존적이다
- 컬렉션들은 기본적으로 지연로딩으로 동작한다!
- 제약사항
  - 엔티티와 다르게 식별자 개념이 없기에 변경하면 추적이 어렵다
  - 컬렉션에 변경사항이 발생하면, 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다
  - 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야한다

### 값 타입 컬렉션 대안

- 실무에서는 값 타입 컬렉션 대신에 일대다 관계를 고려한다
- 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용한다
- 영속선 전이(cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션처럼 사용한다

---

## 객체형 쿼리 언어

검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색

### JPQL

- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- JPQL은 엔티티 객체를 대상으로 쿼리!
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다!
- 한마디로 `객체 지향 SQL`

### Criteria

- 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
- JPQL 빌더 역할
- JPA 공식 기능
- 하지만 너무 복잡하고 실용성이 없다.

### QueryDSL

- 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
- JPQL 빌더 역할
- 컴파일 시점에 문법 오류를 찾을 수 있다
- 동적 쿼리 작성이 편리하다!
- 실무 사용에 적합하다

### 네이티브 SQL

- JPA가 제공하는 SQL을 직접 사용하는 기능
- JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능
  - 오라클 connected by 등

---

## JPQL (Java Persistence Query Language)

### 기본 문법

`select m from Member as m where m.age > 18`

- 엔티티와 속성은 대소문자를 구분한다!
  - Member와 age 같은..
- JPQL 키워드는 대소문자를 구분하지 않는다
  - select, from, where
- 테이블 이름이 아닌, 엔티티 이름을 사용한다
- 별칭(alias)는 필수, as는 생략 가능
- 반환 타입
  - TypeQuery
    - 반환 타입이 명확할 때
  - Query
    - 반환 타입이 명확하지 않을 때

### 프로젝션

Select 절에 조회할 대상을 지정하는 것

- 엔티티, 임베디드 타입, 스칼라 타입
  - `select m From Member m` -> 엔티티 프로젝션
  - `select m.team From Member m` -> 엔티티 프로젝션
  - `select m.address From Member m` -> 임베디드 타입 프로젝션
  - `select m.age, m.username From Member m` -> 스칼라 타입 프로젝션
  - DISTINCT로 중복 제거 가능
- 엔티티 프로젝션된 결과는 영속성 컨텍스트에서 모두 관리가 되며 수정 가능해진다.
- 여러 값을 조회하는 프로젝션에서는 DTO를 사용하자!

### 페이징

JPA는 페이징을 다음 두 API로 추상화

- `setFirstResult(int startPosition)`
  - 조회 시작 위치(0부터 시작)
- `setmaxResults(int maxResult)`
  - 조회할 데이터 수

### JOIN

SQL join과 같지만, 엔티티를 중심으로 join이 진행된다

- 내부 조인
  - `SELECT m FROM Member m [INNER] JOIN m.team t`
- 외부 조인
  - `SELECT m FROM Member m LEFT [OUTER] JOIN m.team t`
- ON 절을 활용한 JOIN
  - 조인 대상 필터링
    - `SELECT m,t FROM Member m LEFT JOIN m.team t on t.name = 'A'`
  - 연관관계가 없는 엔티티 외부 조인
    - `SELECT m,t FROM Member m LEFT JOIN Team t on m.username = t.name`

### SubQuery

`SELECT m from Member m where m.age > (SELECT avg(m2.age) from Member m2)`

- Nested query
- [NOT] EXISTS
  - 서브쿼리에 결과가 존재하면 참
  - {ALL | ANY | SOME} (SubQuery)
  - ALL은 모두 만족하면 참
  - ANY, SOME은 조건을 하나라도 만족하면 참
- [NOT] IN (SubQuery)
  - 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참
- JPA 서브쿼리의 한계
  - JPA 표준 스펙에서는 WHERE, HAVING 절에만 서브쿼리 사용가능..
    - 하지만 `Hibernates`에서는 select절에서도 가능!
  - **FROM 절의 서브쿼리**는 현재 JPQL에서 불가능
    - 조인으로 풀 수 있으면 풀어서 해결해야 한다

### JPQL의 타입 표현

- 문자
  - `' '` single quotation안에 넣으면 된다
  - 'HELLO', 'JPA'
- 숫자
  - 10L(Long), 10D(Double), 10F(Float)
- Boolean
  - TRUE, FALSE
- Enum
  - 패키지명을 포함해서 넣어야한다 (주의!!)


### JPQL 기본함수 및 사용자 정의 함수

- 기본 함수
  - CONCAT
  - SUBSTRING
  - TRIM
  - LOWER, UPPER
  - LENGTH
  - LOCATE
  - ABS, SQRT, MOD
  - SIZE, INDEX(JPA 용도)
  - 또한 DB 종속적으로 이미 `registFunction`으로 등록되어 있는 함수들이 존재한다
- 사용자 정의 함수
  - 사용하는 DB의 dialect를 상속받고, 사용자 정의 함수를 등록해서 사용한다
