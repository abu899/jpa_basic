# JAVA Persistent API(JPA) Basic Study

## 목표

1. 객체와 테이블 설계 매핑
    - 객체와 테이블을 제대로 설계하고 매핑하는 방법
    - 기본 키와 외래 키 ㅁ핑
    - 1:N, N:1, 1:1, N:M 매핑

2. JPA 내부 동작 방식 이해
    - JPA의 내부 동작 방식을 이해하고 사용
    - JPA가 어떤 SQL을 만들어 내는지 이해
    - JPA가 언제 SQL을 실행하는지 이해

### ORM

- Object Relational Mapping(객체 관계 매핑)
- 객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스 대로 설계
- ORM 프레임워크가 중간에서 매핑

### Database Dialect

JPA는 특정 데이터베이스에 종속되지 않는다

- 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 다를 수 있다
    - 가변 문자: MySQL은 VARCHAR, Oracle은 VARCHAR2
    - 문자열을 자르는 함수: SQL 표준은 SUBSTRING(), Oracle은 SUBSTR()
    - 페이징: MySQL은 LIMIT , Oracle은 ROWNUM
- `Dialect`: SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능

## JPA의 구동 방식

<p align="center"><img src="/imgs/1.png" width="80%"></p>

### 주의사항

- `EntityManagerFactory`는 하나만 생성해서 어플리케이션 전체에서 공유한다
- `EntityManger`는 쓰레드간 공유가 안된다
    - 사용하고 버려야한다
- JPA의 모든 데이터는 `Transaction` 안에서 실행된다!! (매우 중요)

---

## Persistent Context (영속성 컨텍스트)

`Entity`를 영구 저장하는 환경이라는 뜻! 엄청나게 중요하다!

- EntityManager.persist(entity)
    - DB에 저장하는게 아니라 entity를 영속성 컨텍스트에 저장한다는 뜻이다
- 사실상 영속성 컨텍스트는 논리적인 개념
- `EntityManager`를 통해서 영속성 컨텍스트에 접근할 수 있다

### Entity의 생명주기

<p align="center"><img src="/imgs/2.png" width="80%"></p>

- 비영속(new/transient)
    - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속(managed)
  - 영속성 컨텍스트에서 관리되는 상태
  - em.persist한 후 commit되거나 find로 찾은 상태이다
- 준영속(detached)
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed)
  - 삭제된 상태

### 장점

- 1차 캐시
  - 영속성 컨텍스트 내부에는 캐시가 존재하여, 중복된 값은 캐시에서 가져올 수 있음
  - JPA에서 관리하는 상태
- 동일성 보장
  - 1차 캐시로 반복 가능한 읽기의 트랜잭션 격리 수준을, 데이터베이스가 아닌 어플리케이션 차원에서 공유
- 트랜잭션을 지원하는 쓰기를 지연한다
  - 트랜잭션을 커밋하는 순간 데이터베이스에 쿼리가 날아간다
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

### flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것

- 변경감지 실행
- 수정된 엔티티에 대한 `쓰기 지연 SQL 저장소`에 등록
- `쓰기 지연 SQL 저장소`의 쿼리를 데이터베이스에 전송한다
- 방법
  - em.flush()
  - 트랜잭션 커밋
  - JPQL 쿼리 실행
- 영속성 컨텍스트를 비우는 것이 아니다!
  - 영속성 컨텍스트의 `변경내용을 데이터베이스에 동기화` 하는것이라고 이해해야한다
- `트랜잭션이라는 작업 단위가 중요`하다
  - 영속성 컨텍스와 트랜잭션의 주기를 맞춰서 개발해야 데이터 동기화 같은 문제가 발생하지 않는다

### 준영속 상태

- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태
- 업데이트 할 때나, 더티 체킹(변경감지)이 불가능해진다
- 방법
  - EntityManager.detach(Entity)
  - EntityManager.clear()
  - EntityManager.close()

---

## Entity Mapping

### Overview

- 객체와 테이블 매핑
  - `@Entity`, `@Table`
- 필드와 컬럼 매핑
  - `@Column`
- 기본 키 매핑
  - `@Id`
- 연관관계 매핑
  - `@ManyToOne`, `@JoinColumn`

### @Entity

- `@Entity`가 붙은 클래스는 JPA가 관리하며 엔티티라고 한다
- JPA를 사용해서 테이블과 매핑하려는 클래스는 반드시! `@Entity` 필수
- 주의
  - 기본 생성자 필수!!(파라미터가 없는 public 또는 protected 생성자)
  - final 클래스, enum, interface, inner 클래스 사용하면 안된다
  - 저장할 필드에 final을 사용하면 안된다

--- 

## 연관관계 매핑 기초

### 목표

- 객체와 테이블 연관관계의 차이를 이해하자
  - 객체는 참조를 사용해서 연관된 관계를 찾는다
  - 테이블은 외래키로 조인을 사용해 연관된 테이블을 찾는다
- 객체의 참조(reference)와 테이블의 외래 키(FK)를 매핑
- 용어의 이해
  - 방향(Direction) : 단방향, 양방향
  - 다중성(Multiplicity) : 1:1, 1:N, N:1, N:N
  - `연관관계의 주인`: 객체 양방향 연관관계는 관리의 주인이 필요하다

### 단방향 연관관계

<p align="center"><img src="/imgs/3.png" width="80%"></p>
<p align="center"><img src="/imgs/4.png" width="80%"></p>

- 한쪽이 다른 한쪽을 참조하는 연관관계

### 양방향 연관관계

<p align="center"><img src="/imgs/5.png" width="80%"></p>

- 서로가 서로를 참조하는 관계
- 테이블 연관관계는 단방향과 차이가 없다

### 연관관계의 주인과 `mappedBy`

객체와 테이블간 연관관계를 맺는 차이를 이해해야한다.

- 객체간 연관관계
  - 양방향 연관관계를 살펴보면 사실 Member-> Team의 단방향 연관관계와 Team -> Member로의 단방향 연관관계
    - 서로의 객체 내에 참조하려는 대상을 가지고 있어야함!
  - 즉 두 개의 단방향 연관관계로 이루어져있다
- 테이블 연관관계 
  - 하지만 테이블 연관관계를 보면 Member의 TEAM_ID라는 외래키를 기준으로 양쪽의 데이터를 얻을 수 있다
    - Member 기준 TEAM_ID FK를 Team의 TEAM_ID PK를 join하면 내가 속한 team을 알 수 있다
    - Team 기준 TEAM_ID PK를 Member의 FK와 join하여 team에 소속된 member를 알 수 있다
  - 즉 테이블 연관관계에서 외래키 하나로 연관관계가 이루어져 있다

그렇다면 객체 두개 중 어떤 걸로 외래키를 관리해야 할까..? 즉 뭘로 매핑을 해야할까?
 
  - Member의 team 값을 바꿧을 때, 외래키 값이 업데이트 해야할까?
  - 아니면 Team의 members가 바꼈을 때, 외래키를 업데이트 해야할까? 

즉, 둘 중 하나로 외래키를 관리해야하는데 이 외래키를 관리하는 주체가 `연관관계의 주인(Owner)`이다.

- Owner만이 외래키를 등록하고 수정할 수 있다
  - 주인이 아닌 쪽은 오로지 읽기만 가능하다.
  - 주인이 아니면 `mappedBy` 속성으로 주인을 지정해줘야한다
- 외래 키가 존재하는 곳을 주인으로 정해야한다!
  - N:1(다대일), 1:N(일대다)같은 경우 N(다)쪽이 무조건 외래키가 있는 곳이므로 주인으로 지정하자

### 양방향 매핑 시 실수 및 주의점

1. 연관관계의 주인이 아닌 반대 객체(가짜 맵핑)에 값을 넣는 경우
  - 앞에 말했듯 주인만이 값을 등록하고 수정할 수 있기 때문에, 반대 객체에만 값을 넣는 경우 외래키가 null이 된다!!
  - 주인에만 값을 셋팅해주면 트랜잭션이 일어나는등 주인 객체의 값이 영속성 컨텍스트에 들어가면서, 반대 객체에도 값이 들어간다.
    - 하지만, 사실상 양쪽 모두에 값을 셋팅해주는게 좋다
    - 만약 영속화 되기전에 반대 객체에 대해 값을 요청한 경우, 아직 JPA가 반대 객체에 값을 넣어주기 전이기 때문에 값을 가져올 수 없다
    - 또한 직관적으로 값을 넣어주지도 않았는데, 값이 들어가는 것보단 비록 읽기만 가능한 반대 객체이지만 값을 넣어주는게 자연스럽다.
  - 따라서, 순수 객체 상태를 고려해서 양쪽에 값을 다 설정하자!
    - 연관관계 편의 메소드를 만들어서 적용하자
    - 연관관계 편의 메소드가 양쪽 객체에 모두 있는 경우 문제가 생길 수 있으므로, 하나의 객체를 정해서 넣어줘야한다.

2. 양방향 매핑시 무한루프를 조심해야한다
   - toString(), lombok, JSON 생성 라이브러리등..
     - StackOverflow Error 호출됨.

3. 단방향 매핑으로 설계를 완료하도록 노력하자.
   - 단방향 매핑으로 구조를 설계하고 꼭 필요할 때에 양방향을 사용하자.
   - 연관관계는 항상 외래키를 기준으로!